// ##################################################################### //
// ----------------------------- s21_negate   --------------------------- //
// ##################################################################### //
#test s21_negate_test
printf("Testing common...\n");
s21_decimal value, result= {0};
value.is_negative = 1;
s21_negate(value, &result);
ck_assert_int_eq(result.is_negative, 0);

#test s21_negate_test2
s21_decimal value, result= {0};
value.is_negative = 0;
s21_negate(value, &result);
ck_assert_int_eq(result.is_negative, 1);


// ##################################################################### //
// ----------------------------- get_bit    ---------------------------- //
// ##################################################################### //
#test get_bit_test1
s21_decimal value = {0};
value.bits[0] = 0b00000000000000000000000000000001;
value.bits[1] = 0b00000000000000000000000000000010;
value.bits[2] = 0b00000000000000000000000000000100;
value.scale = 13;
value.is_negative = 1;
ck_assert_int_eq(get_bit(value, 0), 1); // low bit
ck_assert_int_eq(get_bit(value, 33), 1); // middle bit
ck_assert_int_eq(get_bit(value, 66), 1); // high bit
ck_assert_int_eq(get_bit(value, 1), 0);
ck_assert_int_eq(value.scale, 13); // scale bit
ck_assert_int_eq(value.is_negative, 1); // is_negative bit

// ##################################################################### //
// ----------------------------- set_bit    ---------------------------- //
// ##################################################################### //
#test set_bit_test1
s21_decimal value = {0};
set_bit(&value, 0, 1);
set_bit(&value, 33, 1);
set_bit(&value, 66, 1);
ck_assert_int_eq(value.bits[0], 0b00000000000000000000000000000001);
ck_assert_int_eq(value.bits[1], 0b00000000000000000000000000000010);
ck_assert_int_eq(value.bits[2], 0b00000000000000000000000000000100);

// ##################################################################### //
// ----------------------------- decimal_shift_left    -------------------- //
// ##################################################################### //
#test decimal_shift_left_low_bit
s21_decimal value = {0};
value.bits[0] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(decimal_shift_left(&value, 1), OK); // low bit
ck_assert_int_eq(value.bits[0], 0b00000000000000000000000000000010); // 2

#test decimal_shift_left_middle_bit
s21_decimal value = {0};
value.bits[1] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(decimal_shift_left(&value, 1), OK); // middle bit
ck_assert_int_eq(value.bits[1], 0b00000000000000000000000000000010); // 2

#test decimal_shift_left_high_bit
s21_decimal value = {0};
value.bits[2] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(decimal_shift_left(&value, 1), OK); // high bit
ck_assert_int_eq(value.bits[2], 0b00000000000000000000000000000010); // 2

#test decimal_shift_left_all_bits
s21_decimal value = {0};
value.bits[0] = 0b00000000000000000000000000000001; // 1
value.bits[1] = 0b00000000000000000000000000000001; // 1
value.bits[2] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(decimal_shift_left(&value, 1), OK); // all bits
ck_assert_int_eq(value.bits[0], 0b00000000000000000000000000000010); // 2
ck_assert_int_eq(value.bits[1], 0b00000000000000000000000000000010); // 2
ck_assert_int_eq(value.bits[2], 0b00000000000000000000000000000010); // 2

#test decimal_shift_left_overflow
s21_decimal value = {0};
value.bits[2] = 0b10000000000000000000000000000000;
ck_assert_int_eq(decimal_shift_left(&value, 1), IS_TOO_LARGE); // high bit overflow


// ##################################################################### //
// ----------------------------- make_zero_decimal   --------------------------- //
// ##################################################################### //
#test make_zero_decimal_test
s21_decimal value = {0};
value.bits[0] = 0x77796148;
value.bits[1] = 0x61746f6f;
value.bits[2] = 0x64656542;
value.bits[3] = 0x0073656c;
make_zero_decimal(&value);
ck_assert_int_eq(value.bits[0], 0);
ck_assert_int_eq(value.bits[1], 0);
ck_assert_int_eq(value.bits[2], 0);
ck_assert_int_eq(value.bits[3], 0);

// ##################################################################### //
// ----------------------------- add_decimal_mantissa   --------------------------- //
// ##################################################################### //

#test test_add_simple_values
    s21_decimal a = {{123456789, 0, 0, 0}};
    s21_decimal b = {{111111111, 0, 0, 0}};
    s21_decimal result;

    res_code code = add_decimal_mantissa(a, b, &result);
    ck_assert_int_eq(code, OK);
    ck_assert_int_eq(result.bits[0], 234567900);

#test test_add_with_carry_to_next_bit
    s21_decimal a = {{UINT_MAX, 0, 0, 0}};
    s21_decimal b = {{1, 0, 0, 0}};
    s21_decimal result;

    res_code code = add_decimal_mantissa(a, b, &result);
    ck_assert_int_eq(code, OK);
    ck_assert_int_eq(result.bits[0], 0);
    ck_assert_int_eq(result.bits[1], 1);

#test test_add_overflow
    s21_decimal a = {{UINT_MAX, UINT_MAX, UINT_MAX, 0}};
    s21_decimal b = {{1, 0, 0, 0}};
    s21_decimal result;

    res_code code = add_decimal_mantissa(a, b, &result);
    ck_assert_int_eq(code, IS_TOO_LARGE);

#test test_add_zero
    s21_decimal a = {{0, 0, 0, 0}};
    s21_decimal b = {{987654321, 0, 0, 0}};
    s21_decimal result;

    res_code code = add_decimal_mantissa(a, b, &result);
    ck_assert_int_eq(code, OK);
    ck_assert_int_eq(result.bits[0], 987654321);




// ##################################################################### //
// ----------------------------- decimal_multiply_by_10   --------------------------- //
// ##################################################################### //

#test test_multiply_by10_simple
    s21_decimal val = {{5, 0, 0, 0}};
    int res = decimal_multiply_by_10(&val);
    ck_assert_int_eq(res, OK);
    ck_assert_int_eq(val.bits[0], 50);

#test test_multiply_by10_carry_to_next_bit
    s21_decimal val = {{UINT_MAX, 0, 0, 0}};
    int res = decimal_multiply_by_10(&val);
    ck_assert_int_eq(res, OK);
    ck_assert(val.bits[1] > 0);
    

#test test_multiply_by10_cross_bit_boundary
    s21_decimal val = {{UINT_MAX, 1, 0, 0}}; // немного больше 2^32
    int res = decimal_multiply_by_10(&val);
    ck_assert_int_eq(res, OK);
    // Проверяем, что результат в следующем бите действительно больше 1 и биты сдвинулись
    ck_assert(val.bits[1] > 1);

#test test_multiply_by10_overflow
    s21_decimal val = {{UINT_MAX, UINT_MAX, UINT_MAX, 0}};
    int res = decimal_multiply_by_10(&val);
    ck_assert_int_eq(res, IS_TOO_LARGE);

#test test_multiply_by10_over_scale
    s21_decimal val = {{0, 0, 0, 0}};
    val.scale = 29;
    int res = decimal_multiply_by_10(&val);
    ck_assert_int_eq(res, IS_TOO_LARGE);

#test test_multiply_by10_zero
    s21_decimal val = {{0, 0, 0, 0}};
    int res = decimal_multiply_by_10(&val);
    ck_assert_int_eq(res, OK);
    ck_assert_int_eq(val.bits[0], 0);

#test test_multiply_by10_ignores_sign_and_scale
    s21_decimal val = {0};
    val.is_negative = 1;
    val.scale = 5;
    val.bits[0] = 12345;

    int res = decimal_multiply_by_10(&val);
    ck_assert_int_eq(res, OK);
    ck_assert_int_eq(val.bits[0], 123450);
    ck_assert_int_eq(val.is_negative, 1);
    ck_assert_int_eq(val.scale, 5);


// ##################################################################### //
// ----------------------------- div_by_10   --------------------------- //
// ##################################################################### //

//поделить 0 на 10. ожидание: OK
#test div_by_10_test0
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 0);
ck_assert_int_eq(quotient.scale, 0);

//поделить 1 на 10. ожидание: OK scale = 1, quotient = 0, remainder = 1
#test div_by_10_test1
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.bits[0] = 0b00000000000000000000000000000001; // 1

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 0);
ck_assert_int_eq(quotient.scale, 1);
ck_assert_int_eq(remainder, 1);

//поделить 10 на 10. ожидание: OK scale = 0, quotient = 1, remainder = 0
#test div_by_10_test2
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.bits[0] = 10;

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 1);
ck_assert_int_eq(quotient.scale, 0);
ck_assert_int_eq(remainder, 0);


//поделить -10 на 10. ожидание: OK scale = 0, quotient = -1, remainder = 0
#test div_by_10_test3
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.is_negative = 1;
value.bits[0] = 10;

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 1);
ck_assert_int_eq(quotient.is_negative, 1);
ck_assert_int_eq(quotient.scale, 0);
ck_assert_int_eq(remainder, 0);

// деление 1 на 10 с scale = 28. ожидание: IS_TOO_SMALL
#test div_by_10_test4
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.scale = 28; // максимальный scale
value.bits[0] = 0b00000000000000000000000000000001; // 1

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, IS_TOO_SMALL);


// деление 1 на 10 с scale = 27. ожидание: OK, quotient.scale = 28, remainder = 1
#test div_by_10_test5
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.scale = 27;
value.bits[0] = 0b00000000000000000000000000000001; // 1

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 0);
ck_assert_int_eq(quotient.scale, 28);
ck_assert_int_eq(remainder, 1);

//деление 2^96 на 10 ожидание: OK scale = 0, quotient = 7922816251426433759354395033, remainder = 5
#test div_by_10_test6
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.bits[0] = 0xFFFFFFFF;
value.bits[1] = 0xFFFFFFFF;
value.bits[2] = 0xFFFFFFFF; // 79228162514264337593543950335 - 2^96

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 0b10011001100110011001100110011001);
ck_assert_int_eq(quotient.bits[1], 0b10011001100110011001100110011001);
ck_assert_int_eq(quotient.bits[2], 0b00011001100110011001100110011001);
ck_assert_int_eq(quotient.scale, 0);
ck_assert_int_eq(remainder, 5);