#include "s21_decimal.h"
#include <stdio.h>
#include <math.h>



/*══════════════════════════════════════════════════════════════════════════════════╗
║ ███████╗ ███████╗ ██╗      ███████╗ ███████╗ ██████╗██╗███╗   ███╗ █████╗ ██╗     ║
║ ██╔════╝ ╚════██║ ██║      ██╔═══██╗██╔════╝██╔════╝██║████╗ ████║██╔══██╗██║     ║
║ ███████╗ ███████║ ██║      ██║   ██║█████╗  ██║     ██║██╔████╔██║███████║██║     ║
║ ╚════██║ ██╔════╝ ██║      ██║   ██║██╔══╝  ██║     ██║██║╚██╔╝██║██╔══██║██║     ║
║ ███████║ ███████╗ ██║      ███████╔╝███████╗╚██████╗██║██║ ╚═╝ ██║██║  ██║███████╗║
║ ╚══════╝ ╚══════╝ ╚═╝        ╚════╝ ╚══════╝ ╚═════╝╚═╝╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝║
║                              B I G   D E C I M A L                                ║
╚══════════════════════════════════════════════════════════════════════════════════*/

// ##################################################################### //
// ----------------------------- get_bit    ---------------------------- //
// ##################################################################### //
#test get_bit_test1
s21_decimal value = {0};
value.bits[0] = 0b00000000000000000000000000000001;
value.bits[1] = 0b00000000000000000000000000000010;
value.bits[2] = 0b00000000000000000000000000010000;
value.scale = 13;
value.is_negative = 1;
ck_assert_int_eq(get_bit(value, 0), 1); // low bit
ck_assert_int_eq(get_bit(value, 33), 1); // middle bit
ck_assert_int_eq(get_bit(value, 68), 1); // high bit
ck_assert_int_eq(get_bit(value, 1), 0);
ck_assert_int_eq(value.scale, 13); // scale bit
ck_assert_int_eq(value.is_negative, 1); // is_negative bit

// ##################################################################### //
// ----------------------------- set_bit    ---------------------------- //
// ##################################################################### //
#test set_bit_test1
s21_decimal value = {0};
ck_assert_int_eq(set_bit(&value, 0, 1), OK); // low bit
ck_assert_int_eq(value.bits[0], 0b00000000000000000000000000000001);
ck_assert_int_eq(set_bit(&value, 33, 1), OK); // middle bit
ck_assert_int_eq(value.bits[1], 0b00000000000000000000000000000010);
ck_assert_int_eq(set_bit(&value, 68, 1), OK); // high bit
ck_assert_int_eq(value.bits[2], 0b00000000000000000000000000010000);

// ##################################################################### //
// ----------------------------- decimal_shift_left    -------------------- //
// ##################################################################### //
#test decimal_shift_left_low_bit
s21_decimal value = {0};
value.bits[0] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(decimal_shift_left(&value, 1), OK); // low bit
ck_assert_int_eq(value.bits[0], 0b00000000000000000000000000000010); // 2

#test decimal_shift_left_middle_bit
s21_decimal value = {0};
value.bits[1] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(decimal_shift_left(&value, 1), OK); // middle bit
ck_assert_int_eq(value.bits[1], 0b00000000000000000000000000000010); // 2

#test decimal_shift_left_high_bit
s21_decimal value = {0};
value.bits[2] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(decimal_shift_left(&value, 1), OK); // high bit
ck_assert_int_eq(value.bits[2], 0b00000000000000000000000000000010); // 2

#test decimal_shift_left_all_bits
s21_decimal value = {0};
value.bits[0] = 0b00000000000000000000000000000001; // 1
value.bits[1] = 0b00000000000000000000000000000001; // 1
value.bits[2] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(decimal_shift_left(&value, 1), OK); // all bits
ck_assert_int_eq(value.bits[0], 0b00000000000000000000000000000010); // 2
ck_assert_int_eq(value.bits[1], 0b00000000000000000000000000000010); // 2
ck_assert_int_eq(value.bits[2], 0b00000000000000000000000000000010); // 2

#test decimal_shift_left_overflow
s21_decimal value = {0};
value.bits[2] = 0b10000000000000000000000000000000;
ck_assert_int_eq(decimal_shift_left(&value, 1), OUT_OF_RANGE); // high bit overflow





// ##################################################################### //
// ----------------------------- div_by_10   --------------------------- //
// ##################################################################### //

//поделить 1 на 10. ожидание: OK scale = 1, quotient = 0, remainder = 1
#test div_by_10_test1
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.bits[0] = 0b00000000000000000000000000000001; // 1

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 0);
ck_assert_int_eq(quotient.scale, 1);
ck_assert_int_eq(remainder, 1);

//поделить 10 на 10. ожидание: OK scale = 0, quotient = 1, remainder = 0
#test div_by_10_test2
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.bits[0] = 10;

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 1);
ck_assert_int_eq(quotient.scale, 0);
ck_assert_int_eq(remainder, 0);


//поделить -10 на 10. ожидание: OK scale = 0, quotient = -1, remainder = 0
#test div_by_10_test3
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.is_negative = 1;
value.bits[0] = 10;

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 1);
ck_assert_int_eq(quotient.is_negative, 1);
ck_assert_int_eq(quotient.scale, 0);
ck_assert_int_eq(remainder, 0);

// деление 1 на 10 с scale = 28. ожидание: IS_TOO_SMALL
#test div_by_10_test4
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.scale = 28; // максимальный scale
value.bits[0] = 0b00000000000000000000000000000001; // 1

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, IS_TOO_SMALL);


// деление 1 на 10 с scale = 27. ожидание: OK, quotient.scale = 28, remainder = 1
#test div_by_10_test5
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.scale = 27;
value.bits[0] = 0b00000000000000000000000000000001; // 1

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 0);
ck_assert_int_eq(quotient.scale, 28);
ck_assert_int_eq(remainder, 1);

//деление 2^96 на 10 ожидание: OK scale = 0, quotient = 7922816251426433759354395033, remainder = 5
#test div_by_10_test6
s21_decimal value = {0};
s21_decimal quotient = {0};
unsigned remainder = 0;
int res;
value.bits[0] = 0xFFFFFFFF;
value.bits[1] = 0xFFFFFFFF;
value.bits[2] = 0xFFFFFFFF; // 79228162514264337593543950335 - 2^96

res = div_by_10(value, &quotient, &remainder);

ck_assert_int_eq(res, OK);
ck_assert_int_eq(quotient.bits[0], 0b10011001100110011001100110011001);
ck_assert_int_eq(quotient.bits[1], 0b10011001100110011001100110011001);
ck_assert_int_eq(quotient.bits[2], 0b00011001100110011001100110011001);
ck_assert_int_eq(quotient.scale, 0);
ck_assert_int_eq(remainder, 5);





/*════════════════════════════════════════════════════════════════════════════════╗
║ ██████╗ ██╗ ██████╗      ███████╗ ███████╗ ██████╗██╗███╗   ███╗ █████╗ ██╗     ║
║ ██╔══██╗██║██╔════╝      ██╔═══██╗██╔════╝██╔════╝██║████╗ ████║██╔══██╗██║     ║
║ ██████╔╝██║██║  ███╗     ██║   ██║█████╗  ██║     ██║██╔████╔██║███████║██║     ║
║ ██╔══██╗██║██║   ██║     ██║   ██║██╔══╝  ██║     ██║██║╚██╔╝██║██╔══██║██║     ║
║ ██████╔╝██║╚██████╔╝     ███████╔╝███████╗╚██████╗██║██║ ╚═╝ ██║██║  ██║███████╗║
║ ╚═════╝ ╚═╝ ╚═════╝        ╚════╝ ╚══════╝ ╚═════╝╚═╝╚═╝     ╚═╝╚═╝  ╚═╝╚══════╝║
║                              B I G   D E C I M A L                              ║
╚════════════════════════════════════════════════════════════════════════════════*/



// ##################################################################### //
// ----------------------------- bigdec_get_bit    ---------------------------- //
// ##################################################################### //
#test bigdec_get_bit_test1
big_decimal value = {0};
value.bits[0] = 0b00000000000000000000000000000001;
value.bits[1] = 0b00000000000000000000000000000010;
value.bits[2] = 0b00000000000000000000000000010000;
value.scale = 13;
value.is_negative = 1;
ck_assert_int_eq(bigdec_get_bit(value, 0), 1); // low bit
ck_assert_int_eq(bigdec_get_bit(value, 33), 1); // middle bit
ck_assert_int_eq(bigdec_get_bit(value, 68), 1); // high bit
ck_assert_int_eq(bigdec_get_bit(value, 1), 0);
ck_assert_int_eq(value.scale, 13); // scale bit
ck_assert_int_eq(value.is_negative, 1); // is_negative bit



// ##################################################################### //
// ----------------------------- bigdec_set_bit    ---------------------------- //
// ##################################################################### //
#test bigdec_set_bit_test1
big_decimal value = {0};
ck_assert_int_eq(bigdec_set_bit(&value, 0, 1), OK); // low bit
ck_assert_int_eq(value.bits[0], 0b00000000000000000000000000000001);
ck_assert_int_eq(bigdec_set_bit(&value, 33, 1), OK); // middle bit
ck_assert_int_eq(value.bits[1], 0b00000000000000000000000000000010);
ck_assert_int_eq(bigdec_set_bit(&value, 68, 1), OK); // high bit
ck_assert_int_eq(value.bits[2], 0b00000000000000000000000000010000);



// ##################################################################### //
// ----------------------------- bigdec_shift_left    -------------------- //
// ##################################################################### //
#test bigdec_shift_left_low_bit
big_decimal value = {0};
value.bits[0] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(bigdec_shift_left(&value, 1), OK); // low bit
ck_assert_int_eq(value.bits[0], 0b00000000000000000000000000000010); // 2

#test bigdec_shift_left_middle_bit
big_decimal value = {0};
value.bits[1] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(bigdec_shift_left(&value, 1), OK); // middle bit
ck_assert_int_eq(value.bits[1], 0b00000000000000000000000000000010); // 2

#test bigdec_shift_left_high_bit
big_decimal value = {0};
value.bits[2] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(bigdec_shift_left(&value, 1), OK); // high bit
ck_assert_int_eq(value.bits[2], 0b00000000000000000000000000000010); // 2

#test bigdec_shift_left_all_bits
big_decimal value = {0};
value.bits[0] = 0b00000000000000000000000000000001; // 1
value.bits[1] = 0b00000000000000000000000000000001; // 1
value.bits[2] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(bigdec_shift_left(&value, 1), OK); // all bits
ck_assert_int_eq(value.bits[0], 0b00000000000000000000000000000010); // 2
ck_assert_int_eq(value.bits[1], 0b00000000000000000000000000000010); // 2
ck_assert_int_eq(value.bits[2], 0b00000000000000000000000000000010); // 2

#test bigdec_shift_left_overflow
big_decimal value = {0};
value.bits[6] = 0b10000000000000000000000000000000;
ck_assert_int_eq(bigdec_shift_left(&value, 1), OUT_OF_RANGE); // high bit overflow


// ##################################################################### //
// ----------------------------- bigdec_add_mantissa    -------------------- //
// ##################################################################### //
#test bigdec_add_mantissa_test1
big_decimal value1 = {0};
big_decimal value2 = {0};
big_decimal value3 = {0};
value1.bits[0] = 0b00000000000000000000000000000001; // 1
value2.bits[0] = 0b00000000000000000000000000000001; // 1
ck_assert_int_eq(bigdec_add_mantissa(value1, value2, &value3), OK); // 1 + 1 = 2
ck_assert_int_eq(value3.bits[0], 0b00000000000000000000000000000010); // 2
ck_assert_int_eq(value3.bits[1], 0); // no overflow


#test bigdec_add_mantissa_test2
big_decimal value1 = {0};
big_decimal value2 = {0};
big_decimal value3 = {0};
value1.bits[0] = 0b11111111111111111111111111111111;
value2.bits[0] = 0b11111111111111111111111111111111;
ck_assert_int_eq(bigdec_add_mantissa(value1, value2, &value3), OK);
ck_assert_int_eq(value3.bits[0], 0b11111111111111111111111111111110); 
ck_assert_int_eq(value3.bits[1], 1);

#test bigdec_add_mantissa_test3
big_decimal value1 = {0};
big_decimal value2 = {0};
big_decimal value3 = {0};
value1.bits[0] = 0b11111111111111111111111111111111;
value1.bits[1] = 0b11111111111111111111111111111111; 

value2.bits[0] = 0b11111111111111111111111111111111; 
value2.bits[1] = 0b11111111111111111111111111111111; 
ck_assert_int_eq(bigdec_add_mantissa(value1, value2, &value3), OK); 
ck_assert_int_eq(value3.bits[0], 0b11111111111111111111111111111110);  
ck_assert_int_eq(value3.bits[1], 0b11111111111111111111111111111111);   
ck_assert_int_eq(value3.bits[2], 1);

//складываемые числа больше чем 2^96
#test bigdec_add_mantissa_test4
big_decimal value1 = {0};
big_decimal value2 = {0};
big_decimal value3 = {0};
for (int i = 0; i < INTS_IN_BIGDECIMAL; i++) {
    value1.bits[i] = 0xFFFFFFFF;
    value2.bits[i] = 0xFFFFFFFF;
}
ck_assert_int_eq(bigdec_add_mantissa(value1, value2, &value3), OK); 
ck_assert_int_eq(value3.bits[0], 0b11111111111111111111111111111110);
for (int i = 1; i < INTS_IN_BIGDECIMAL-1; i++) {
    ck_assert_int_eq(value3.bits[i], 0b11111111111111111111111111111111);
}
ck_assert_int_ne(value3.bits[7], 0); //переполнение, т.е. старший бит не ноль


// ##################################################################### //
// ----------------------------- bigdec_multiply_by10-------------------- //
// ##################################################################### //

#test bigdec_multiply_by10_test1
big_decimal value1 = {0};
value1.bits[0] = 1;
for(int i=0; i < 5; i++) {
    bigdec_multiply_by10(&value1);
    value1.scale++;
    ck_assert_int_eq(value1.bits[0], pow(10, i+1)); // 1 * 10^5 = 100000
    ck_assert_int_eq(value1.scale, i+1); // scale should remain 0
}


// ##################################################################### //
// ----------------------------- bigdec_Allignment -------------------- //
// ##################################################################### //
#test bigdec_Allignment_test1
big_decimal value1 = {0};
big_decimal value2 = {0};

value1.bits[0] = 1;
value1.scale = 5;
value2.bits[0] = 1;
value2.scale = 0;
ck_assert_int_eq(bigdec_alignment(&value1, &value2), OK);
ck_assert_int_eq(value1.scale, 5);
ck_assert_int_eq(value2.scale, 5);
ck_assert_int_eq(value1.bits[0], 1);
ck_assert_int_eq(value2.bits[0], 100000); // 1 * 10^5


#test bigdec_Allignment_test2
big_decimal value1 = {0};
big_decimal value2 = {0};

value1.bits[0] = 1;
value1.scale = 0;
value2.bits[0] = 1;
value2.scale = 5;
ck_assert_int_eq(bigdec_alignment(&value1, &value2), OK);
ck_assert_int_eq(value1.scale, 5);
ck_assert_int_eq(value2.scale, 5);
ck_assert_int_eq(value1.bits[0], 100000); // 1 * 10^5
ck_assert_int_eq(value2.bits[0], 1);


// ##################################################################### //
// ----------------------------- bigdec_is_zero ----------------------- //
// ##################################################################### //
#test bigdec_is_zero_test1
    big_decimal bdcm1 = {0};
    ck_assert_int_eq(bigdec_is_zero(bdcm1), TRUE); // все нули

#test bigdec_is_zero_test2
    big_decimal bdcm1 = {0};
    bdcm1.bits[0] = 1; // не ноль
    ck_assert_int_eq(bigdec_is_zero(bdcm1), FALSE); // все нули


// ##################################################################### //
// ----------------------------- decimal_to_bigdec ----------------------- //
// ##################################################################### //

#test decimal_to_bigdec_test1
s21_decimal dcm1 = {0};
big_decimal bdcm1 = {0};

dcm1.low = 123;
dcm1.is_negative = 1;
dcm1.scale = 5;
ck_assert_int_eq(decimal_to_bigdec(dcm1, &bdcm1), OK);
ck_assert_int_eq(bdcm1.mantissa[0], 123);
ck_assert_int_eq(bdcm1.mantissa[1], 0);
ck_assert_int_eq(bdcm1.mantissa[2], 0); // остальные нули
ck_assert_int_eq(bdcm1.mantissa[3], 0);
ck_assert_int_eq(bdcm1.mantissa[4], 0);
ck_assert_int_eq(bdcm1.mantissa[5], 0);
ck_assert_int_eq(bdcm1.mantissa[6], 0);
ck_assert_int_eq(bdcm1.lower_word, 0);
ck_assert_int_eq(bdcm1.scale, 5);
ck_assert_int_eq(bdcm1.zero, 0);
ck_assert_int_eq(bdcm1.is_negative, 1); // is_negative должен быть 1



// ##################################################################### //
// ----------------------------- bigdec_div_mantissa -------------------- //
// ##################################################################### //

#test bigdec_div_mantissa_8_2
    big_decimal bdcm1 = {0};
    big_decimal bdcm2 = {0};
    big_decimal bdcm3 = {0};

    bdcm1.bits[0] = 0b00000000000000000000000000001000; // 8
    bdcm2.bits[0] = 2;

    bigdec_div_mantissa(bdcm1, bdcm2, &bdcm3);
    ck_assert_int_eq(bdcm3.bits[0], 0b00000000000000000000000000000100); // 4   


#test bigdec_div_mantissa_8589934590_2
    big_decimal bdcm1 = {0};
    big_decimal bdcm2 = {0};
    big_decimal bdcm3 = {0};

    bdcm1.bits[0] = 0b11111111111111111111111111111110; // 4294967294
    bdcm1.bits[1] = 1; // 8589934590

    bdcm2.bits[0] = 2;

    bigdec_div_mantissa(bdcm1, bdcm2, &bdcm3);
    ck_assert_int_eq(bdcm3.bits[0], 4294967295); // 4294967295   


#test bigdec_div_mantissa_8589934590_10
    big_decimal bdcm1 = {0};
    big_decimal bdcm2 = {0};
    big_decimal bdcm3 = {0};

    bdcm1.bits[0] = 0b11111111111111111111111111111110; // 4294967294
    bdcm1.bits[1] = 1; // 8589934590

    bdcm2.bits[0] = 10;

    bigdec_div_mantissa(bdcm1, bdcm2, &bdcm3);
    ck_assert_int_eq(bdcm3.bits[0], 858993459); 


// ##################################################################### //
// ----------------------------- bigdec_div_by_10 -------------------- //
// ##################################################################### //

// #test bigdec_div_by_10_test1
//     big_decimal bdcm1 = {0};

//     bdcm1.bits[0] = 0b11111111111111111111111111111110; // 4294967294
//     bdcm1.bits[1] = 1; // 8589934590

//     bigdec_div_by_10(&bdcm1);
//     ck_assert_int_eq(bdcm1.bits[0], 858993459); 

